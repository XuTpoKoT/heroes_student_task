## Heroes

### Алгоритмическая сложность метода generate
Шаги алгоритма:

1. Вычисление эффективности юнитов: `O(n)`
2. Сортировка типов по эффективности: `O(n log n)`
3. Жадное формирование армии: `O(k)`

Итоговая сложность:
O(n log n + k)

### Алгоритмическая сложность метода simulate
Обозначения:

- `P` — количество юнитов в армии игрока
- `C` — количество юнитов в армии компьютера
- `N = P + C` — общее количество юнитов

Временная сложность на один цикл хода:

1. Формирование очереди `turnQueue`: `O(P + C) = O(N)`
2. Сортировка очереди по атаке: `O(N log N)`
3. Обход очереди и атака: `O(N)` (каждый юнит может атаковать один раз)

Сложность одного раунда:
O(N log N)


Общее количество раундов: зависит от живучести юнитов и боевых условий.  
Пусть `R` — количество раундов до победы одной из армий, тогда временная сложность всей симуляции:

O(R * N log N)

### Алгоритмическая сложность метода getSuitableUnits
Обозначения:

- `m` — количество рядов (`m = 3`)
- `n` — максимальное количество юнитов в ряду

Шаги алгоритма:

1. Перебор всех рядов: `O(m)`
2. Перебор всех юнитов в ряду: `O(n)`  
   → проверка соседних клеток выполняется за `O(1)`

Итоговая сложность:
O(m * n)

### Алгоритмическая сложность метода getTargetPath
Обозначения:

- `WIDTH` — ширина поля (27)
- `HEIGHT` — высота поля (21)
- `N = WIDTH * HEIGHT` — общее количество клеток

BFS:

- Каждая клетка добавляется в очередь не более одного раза → `O(N)`
- Для каждой клетки проверяется 8 соседей → `O(8 * N) = O(N)`

Итоговая сложность:
O(WIDTH * HEIGHT) = O(N)
